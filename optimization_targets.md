# Performance Optimization Targets - Initial Identification

This document lists potential areas for performance optimization identified during the initial codebase review. Each target includes a description, its potential impact, the rationale for its inclusion, and relevant file locations.

## 1. Image Optimization with `next/image`

*   **Description**: Currently, the application primarily uses standard `<img>` tags with URLs generated by Sanity's `urlFor` helper. Implementing Next.js's built-in `<Image>` component can provide significant performance benefits.
*   **Potential Impact**: High
*   **Rationale**: The `next/image` component offers automatic image optimization, including:
    *   **Resizing**: Serving appropriately sized images for different devices.
    *   **Format Optimization**: Converting images to modern formats like WebP where supported.
    *   **Lazy Loading**: Deferring the loading of offscreen images until they are about to enter the viewport.
    *   This leads to faster page load times (especially Largest Contentful Paint - LCP) and reduced bandwidth consumption.
*   **Relevant Files**:
    *   `components/Product.jsx`
    *   `pages/product/[slug].js` (product detail images, small gallery images)
    *   `components/Cart.jsx` (cart item images)
    *   Potentially other components displaying images from Sanity.

## 2. Homepage Data Fetching Strategy

*   **Description**: The homepage (`pages/index.js`) currently uses `getServerSideProps` to fetch all products and banner data on every request.
*   **Potential Impact**: Medium to High (depending on the total number of products and banners)
*   **Rationale**: `getServerSideProps` renders the page on the server for each request. If the product and banner data do not change very frequently, switching to `getStaticProps` with Incremental Static Regeneration (ISR) using the `revalidate` option would be more performant. This allows Next.js to serve statically generated pages from a CDN, reducing server load and improving response times. Additionally, fetching *all* products might be excessive if the number of products is large; consider fetching a curated subset for the homepage.
*   **Relevant Files**:
    *   `pages/index.js`

## 3. "You May Also Like" Data Fetching Strategy

*   **Description**: The product details page (`pages/product/[slug].js`) fetches *all* products via `getStaticProps` to populate the "You may also like" section.
*   **Potential Impact**: Medium
*   **Rationale**: Fetching all products for every product page can be inefficient, especially during build times if there are many products, or if revalidation occurs frequently. A more targeted approach would be better, such as:
    *   Fetching products from the same category.
    *   Fetching a predefined number of random products.
    *   Fetching products based on collaborative filtering or other recommendation logic (more advanced).
    *   This reduces data over-fetching and can speed up page generation/revalidation.
*   **Relevant Files**:
    *   `pages/product/[slug].js`

## 4. JavaScript Bundle Size Analysis

*   **Description**: Analyze the client-side JavaScript bundles to identify large dependencies or chunks that could be optimized.
*   **Potential Impact**: Medium to High
*   **Rationale**: Large JavaScript bundles increase initial page load times and can delay interactivity (Time to Interactive - TTI). Tools like `@next/bundle-analyzer` can visualize bundle contents, helping to identify:
    *   Large third-party libraries that might have smaller alternatives or could be code-split.
    *   Unused code that could be eliminated through better tree-shaking.
    *   Opportunities for dynamic imports (`next/dynamic`) for components not needed on initial load.
*   **Relevant Files**: This is a general analysis, but entry points are `pages/_app.js` and individual page components.

## 5. React Re-render Optimization

*   **Description**: Investigate React component re-renders to ensure they are not happening unnecessarily.
*   **Potential Impact**: Low to Medium
*   **Rationale**: Unnecessary re-renders can lead to a sluggish user interface, especially in complex components or those that consume frequently updated context (`StateContext.js`). Using React DevTools Profiler can help identify these issues. Optimization techniques include:
    *   `React.memo` for functional components.
    *   `useMemo` for memoizing expensive calculations.
    *   `useCallback` for memoizing callback functions passed to child components.
    *   Careful structuring of props and state.
*   **Relevant Files**:
    *   `context/StateContext.js` (and its consumers)
    *   `components/Cart.jsx`
    *   `pages/product/[slug].js` (due to its various stateful interactions)
    *   Other complex components.

## 6. CSS Optimization

*   **Description**: Review CSS usage for potential optimizations.
*   **Potential Impact**: Low to Medium
*   **Rationale**: While modern frameworks handle much of CSS delivery, potential issues include:
    *   Unused CSS styles that add to file size.
    *   Overly complex selectors that can be slow for the browser to parse.
    *   Ensuring efficient loading strategies (e.g., critical CSS).
    *   Next.js handles CSS splitting per page, which is good. A review can ensure `globals.css` isn't overly bloated.
*   **Relevant Files**:
    *   `styles/globals.css`
    *   CSS Modules or styled-components if used within components.

## 7. Sanity Query Efficiency

*   **Description**: Review GROQ queries made to Sanity for efficiency and data minimization.
*   **Potential Impact**: Low to Medium
*   **Rationale**: Ensure queries only fetch the data fields actually needed for rendering. Over-fetching data increases transfer times and memory usage.
    *   Example: If a product list only needs name, slug, price, and main image, the query shouldn't fetch the entire product document (e.g., full details, all images, etc.). Use projections in GROQ.
    *   The current queries (e.g., `*[_type == "product"]`) fetch all fields.
*   **Relevant Files**:
    *   `pages/index.js` (getServerSideProps)
    *   `pages/product/[slug].js` (getStaticProps for product and all products)
    *   `lib/client.js` (though queries are defined in pages)

## 8. Stripe API Image Handling

*   **Description**: The `pages/api/stripe.js` route manually constructs image URLs for line items sent to Stripe.
*   **Potential Impact**: Very Low (primarily a robustness/maintainability concern)
*   **Rationale**: While the current manual string replacement for image URLs works, using Sanity's `urlFor()` builder (from `lib/client.js`) would be more robust if Sanity's CDN URL structure or image processing parameters were to change. This is unlikely to be a performance bottleneck but improves code quality.
*   **Relevant Files**:
    *   `pages/api/stripe.js`

---

## Second Pass Identification

The following targets were identified or refined during a second review of the codebase and project setup.

## 9. Investigate `next-sanity-image` Usage

*   **Description**: The project includes `next-sanity-image` in its `package.json` dependencies. This library is specifically designed to integrate Sanity images with Next.js's `next/image` component. However, the initial code review primarily found manual `<img>` tag usage with `urlFor()`.
*   **Potential Impact**: High (directly relates to and could simplify Target #1)
*   **Rationale**: If `next-sanity-image` is a well-maintained and effective library, utilizing it could be a more streamlined approach to implementing `next/image` capabilities for Sanity assets compared to writing custom loaders. It's crucial to determine if this library is already in use, partially implemented, or was a planned enhancement that wasn't fully integrated. Understanding its status will inform the best way to proceed with image optimization.
*   **Relevant Files**:
    *   `package.json`
    *   Components currently using `<img>` for Sanity images (e.g., `components/Product.jsx`, `pages/product/[slug].js`).
    *   Any existing usage of `next-sanity-image`.

## 10. Dynamic Import for Non-Critical Components/Libraries

*   **Description**: Identify components or libraries that are not essential for the initial page render and could be loaded on demand using `next/dynamic`. One candidate is `canvas-confetti`, used for visual feedback.
*   **Potential Impact**: Medium
*   **Rationale**: Dynamically importing JavaScript for components or libraries that are only needed under certain conditions (e.g., after a user interaction, for content below the fold, or for decorative effects like confetti) can reduce the initial JavaScript bundle size. This leads to faster Time to Interactive (TTI) and improved loading performance for the main content.
*   **Relevant Files**:
    *   `package.json` (for `canvas-confetti`)
    *   `context/StateContext.js` (where `toast.success` might trigger confetti indirectly, or components that directly use it)
    *   Any large components that are conditionally rendered or appear far down a page.

## 11. MUI Bundle Size Contribution (Refinement of Target #4)

*   **Description**: Material UI (`@mui/material`) is a comprehensive UI library. As part of the JavaScript Bundle Size Analysis (Target #4), pay specific attention to how MUI components are imported and bundled.
*   **Potential Impact**: Medium to High
*   **Rationale**: MUI offers many components and utilities. If imports are not granular (e.g., using top-level imports like `import { Button, Card } from '@mui/material';` vs. direct path imports if tree-shaking isn't optimal for the setup: `import Button from '@mui/material/Button';`), it can contribute significantly to the bundle size. The `@next/bundle-analyzer` will help identify if MUI is a major factor and if tree-shaking is working effectively.
*   **Relevant Files**:
    *   Any files importing components from `@mui/material` (e.g., `components/Cart.jsx` uses `SwipeableDrawer`).
    *   `package.json`

## 12. Web Font Loading Strategy (Refinement of Target #6)

*   **Description**: As part of CSS Optimization (Target #6), specifically investigate the loading strategy for web fonts. Currently, no explicit font preloading or configuration is visible in `pages/_document.js`. Fonts are likely loaded via CSS imports (e.g., in `styles/globals.css`) or as part of a UI library like MUI.
*   **Potential Impact**: Medium
*   **Rationale**: Web font loading can significantly impact perceived performance and Core Web Vitals like Cumulative Layout Shift (CLS) and Largest Contentful Paint (LCP).
    *   Ensure `font-display: swap;` (or `optional`) is used in `@font-face` declarations to prevent invisible text while fonts load.
    *   Consider preloading critical fonts if they are discovered late by the browser.
    *   Verify that fonts are self-hosted if possible for better control and to avoid extra DNS lookups, or that CDN-hosted fonts are using appropriate `preconnect` hints.
*   **Relevant Files**:
    *   `styles/globals.css`
    *   Any theme configuration files for MUI that might declare fonts.
    *   `pages/_document.js` (for potential preloading).
```
